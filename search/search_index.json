{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This style guide is written by SilentsReplacement and only intended for code that belongs to a game of PerduxStudios . It is mostly similar to Roblox Luau's Style Guide except with cmdnoticeable changes and style changes and will continue to get changed eventually as time passes on. Starting principles Consistency is very important, code inconsistencies makes it hard for other developers to review your code and in general makes your code harder to maintain and less readable. Always declare variables and functions locally, unless you want a variable to fully accessed from any scope. Global variables that reference a table, function, userdata, thread, string will not be garbage collected unless the global variable is set to nil explicitly or when the script ends. Never micro optimize code. Code should only be optimized if the performance gains are going to be significant and only when needed. Avoid magic values and dangerous code. Use constants over magic value that you use more than once. Constants help maintain code and will also help you not to constantly change your code if you change any crucial value. Magic values are nice, unless the code doesn't work as intended and will be extremely hard to debug because most of the times you won't know what went wrong, or you would be required to change your code because you changed a magic value to something else. Variable names should be verbose, even if they get a little to long. Never declare variables like x , plr , etc. Who would want to read variables like those?! Don't use variables for values you only use once, don't clutter code with unnecessary variables. Again, they make code slightly more harder to maintain and harder for other developers to review your code. Exceptions include if you use a variable to reference a service, module, or an object created from a prototype class that acts like an service. Keep a header for every script you code in, this helps other developers know who is the maintainer of what code and in general improves collaboration. Version control is also a option but isn't that dynamic. The format for the header should be as follows: -- AUTHOR_NAME -- SCRIPT_NAME -- MONTH DATE, YEAR Always write clean and efficient code. Code that has certain edge cases unhandled / silent bugs is bad code. File Structure Files should consist of these things (if present) in order: A header. Services used by the file, via GetService . ModuleScript s used by the file. Note that objects created by an prototype class that refer to services or a package are also considered an ModuleScript. Any constants used by the file. Variables (If they hold a reference to an object created by an prototype class, they should be first before any other variable, tables must be at the last, booleans/numbers/strings can be in any order). A return statement (if the file is a ModuleScript ). Requiring an module Use relative paths when importing modules from the same package. local Roact = require ( script . Parent . Roact ) Use absolute paths when importing modules from a different package. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fin = require ( ReplicatedStorage . Shared . Module ) Naming Spell out words fully! Abbreviations generally make code easier to write, but harder to read. Use PascalCase for classes, enum/service-like objects and public table members. Use camelCase for local variables. Also for private members and private functions, except prefixed with an underscore. Use LOUD_SNAKE_CASE names for constants. Modules should be named whatever they export and return. If you have a module that returns a custom yielding function which uses RunService.Heartbeat , the module should be named Heartbeat . Prototype Classes First of, Luau has no concept of classes, hence a class in Lua is actually a prototype class or a object where other objects inherit from it, also known as Prototype Inheritance . First up, we create a empty table which will be the prototype class: local MyClass = {} Next, we assign the __index member on the class back to itself. This is a handy trick that lets us use the class's table as the metatable for instances as well. When we construct an instance, we'll tell Lua to use our __index value to find values that are missing in our instances: MyClass . __index = MyClass In most cases, we create a default constructor for our class. By convention, we usually call it new. Methods that don't operate on instances of our class are usually defined using a dot (.) (static methods) instead of a colon (:) (instance methods): function MyClass . new () return setmetatable ({ phrase = \"bark\" }, MyClass ) end -- This is functionally identical to `function MyClass.bark(self)` function MyClass : bark () print ( \"My phrase is\" , self . phrase ) end We can construct instances (objects) and start tinkering with it: local instance = MyClass . new () -- Properties on the instance are visible, since it's just a table: print ( instance . phrase ) -- \"bark\" -- Methods are pulled from MyClass because of our metatable: instance : bark () -- \"My phrase is bark\" -- We can also invoke methods with a dot by explicitly passing `instance`: MyClass . bark ( instance ) instance . bark ( instance ) Further additions you can make to your class as needed: Introduce a __tostring metamethod to make debugging easier. Add a method to check type given an instance, like: function MyClass . IsMyClass ( instance ) return getmetatable ( instance ). __index == MyClass end General Whitespace It's always best to indent with tabs. Keep lines under 140 columns wide, assuming four column wide tabs. Wrap comments to 100 columns wide, assuming four column wide tabs. This is different than normal code; the hope is that short lines help improve readability of comment prose, but is too restrictive for code. Don't leave whitespace at the end of lines. Add a newline at the end of the file. No vertical alignment, they make code more difficult to edit and it's hard to keep exact precision and is a tedious process to do so anyways. Good : local bo = 132 local nanako = 17 Bad : local bo = 132 local nanako = 17 Use one statement per line. Put function bodies on new lines: Good : table.sort ({}, function ( a , b ) local sum = a + b return math.abs ( sum ) > 2 end ) Bad : table.sort ({}, function ( a , b ) local sum = a + b return math.abs ( sum ) > 2 end This is also true for if blocks, even if their body is just a return statement. Consistency is important! Good : if valueIsInvalid then return end Bad : if valueIsInvalid then return end Put function arguments (if they're too long) in new lines and expand the whitespace for the call: Good : local function foo (...) return ... end foo ( 1 , 2 , {}, {}, function () end , function () print ( \"test\" ) end ) Bad : local function foo (...) return ... end foo ( 1 , 2 , {}, {}, function () end , function () print ( \"test\" ) end ) Put a space before and after operators, except when clarifying precedence: Good : print ( 2 + 2 - 4 / 4 ) Bad : print ( 2 + 2 - 4 / 4 ) Avoid putting curly braces for tables on their own line. Doing so harms readability, since it forces the reader to move to another line in an awkward spot in the statement. Good : local foo = { bar = { baz = \"baz\" , }, } frob ({ x = 1 , }) Bad : local foo = { bar = { baz = \"baz\" , }, } frob ( { x = 1 , }) Exception: In function calls with large inline tables or functions, sometimes it's more clear to put braces and functions on new lines: foo ( { type = \"foo\" , bo = \"e\" , \"2\" {}, {} }, function ( something ) print ( \"Hello,\" something ) end ) Break dictionary-like tables with more than a couple keys onto multiple lines: Good : local profile = { Data = { Cash = 0 , Level = 1 }, MetaData = {} } Bad : local profile = { Data = { Cash = 0 , Level = 1 }, MetaData = {}} Guarding against silent errors Indexing into a table in Luau gives you nil if the key isn't present, which can cause errors that are difficult to trace! Our other major use case for metatables is to prevent certain forms of this problem. For types that act like enums, we can carefully apply an __index metamethod that throws: local MyEnum = { A = \"A\" , B = \"B\" , C = \"C\" , } setmetatable ( MyEnum , { __index = function ( self , key ) error ( string.format ( \"%q is not a valid member of MyEnum\" , tostring ( key )), 2 ) end , }) Since the __index metamethod is only called when a key is missing in the table, MyEnum.A and MyEnum.B will still give you back the expected values. But MyEnum.Typo will result in an error. Some nice debugging practices. Blocks Don't use parentheses around the conditions in if, while, or repeat blocks. They aren't necessary in Luau and usually harm readability. Good : if CONDITION then end while CONDITION do end Bad : if ( CONDITION ) then end while ( CONDITION ) do end Use do blocks if limiting the scope of a variable is useful: local getId do local lastId = 0 getId = function () lastId = lastId + 1 return lastId end end String literals Use double quotes when declaring string literals. Good : local message = \"Hi\" Bad : local message = 'Hi' Use single quotes when declaring string literals that represent characters. Good : local characterA = 'A' Bad : local characterA = \"A\" Events and yielding Never unnecessary poll if you can use an event instead. Busy polling is bad practice as it constantly yields the thread back and forth, while yielding until an event is fired simply yields the thread once, and resumes it once. Remember the rule: Event Driven Programming > Unnecessary polling . Good : local Players = game : GetService ( \"Players\" ) local MIN_PLAYER_COUNT = 3 -- Wait for enough players to start: local playerCount = # Players : GetPlayers () while playerCount < MIN_PLAYER_COUNT do Players . PlayerAdded : Wait () playerCount += 1 -- Don't use GetPlayers() unnecessary end Bad : local Players = game : GetService ( \"Players\" ) local MIN_PLAYER_COUNT = 3 -- Wait for enough players to start: local playerCount = # Players : GetPlayers () while playerCount < MIN_PLAYER_COUNT do playerCount = # Players : GetPlayers () wait () end Garbage collection Always make sure strong references do get cleared in your code. Never have a reference that is never cleared. An reference type object (table, userdata, string, function, thread) are garbage collected when they have 0 references. Functions that use an external local variable hold reference to them (assuming they're reference type objects). The function will only no longer hold a reference to them once the function it self is garbage collected. Always disconnect events when they're no longer in need. Events hold an internal reference to the connected callback, and that callback will not be garbage collected unless the event it self is disconnected (event's disconnected no longer reference the connected callback). You can use a Maid to easily track events and clean them up. Comments You don't need to necessarily use comments if the code is self explanatory. Although comments should both explain why and what the code is doing in simple terms.","title":"Home"},{"location":"#home","text":"This style guide is written by SilentsReplacement and only intended for code that belongs to a game of PerduxStudios . It is mostly similar to Roblox Luau's Style Guide except with cmdnoticeable changes and style changes and will continue to get changed eventually as time passes on.","title":"Home"},{"location":"#starting-principles","text":"Consistency is very important, code inconsistencies makes it hard for other developers to review your code and in general makes your code harder to maintain and less readable. Always declare variables and functions locally, unless you want a variable to fully accessed from any scope. Global variables that reference a table, function, userdata, thread, string will not be garbage collected unless the global variable is set to nil explicitly or when the script ends. Never micro optimize code. Code should only be optimized if the performance gains are going to be significant and only when needed. Avoid magic values and dangerous code. Use constants over magic value that you use more than once. Constants help maintain code and will also help you not to constantly change your code if you change any crucial value. Magic values are nice, unless the code doesn't work as intended and will be extremely hard to debug because most of the times you won't know what went wrong, or you would be required to change your code because you changed a magic value to something else. Variable names should be verbose, even if they get a little to long. Never declare variables like x , plr , etc. Who would want to read variables like those?! Don't use variables for values you only use once, don't clutter code with unnecessary variables. Again, they make code slightly more harder to maintain and harder for other developers to review your code. Exceptions include if you use a variable to reference a service, module, or an object created from a prototype class that acts like an service. Keep a header for every script you code in, this helps other developers know who is the maintainer of what code and in general improves collaboration. Version control is also a option but isn't that dynamic. The format for the header should be as follows: -- AUTHOR_NAME -- SCRIPT_NAME -- MONTH DATE, YEAR Always write clean and efficient code. Code that has certain edge cases unhandled / silent bugs is bad code.","title":"Starting principles"},{"location":"#file-structure","text":"Files should consist of these things (if present) in order: A header. Services used by the file, via GetService . ModuleScript s used by the file. Note that objects created by an prototype class that refer to services or a package are also considered an ModuleScript. Any constants used by the file. Variables (If they hold a reference to an object created by an prototype class, they should be first before any other variable, tables must be at the last, booleans/numbers/strings can be in any order). A return statement (if the file is a ModuleScript ).","title":"File Structure"},{"location":"#requiring-an-module","text":"Use relative paths when importing modules from the same package. local Roact = require ( script . Parent . Roact ) Use absolute paths when importing modules from a different package. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fin = require ( ReplicatedStorage . Shared . Module )","title":"Requiring an module"},{"location":"#naming","text":"Spell out words fully! Abbreviations generally make code easier to write, but harder to read. Use PascalCase for classes, enum/service-like objects and public table members. Use camelCase for local variables. Also for private members and private functions, except prefixed with an underscore. Use LOUD_SNAKE_CASE names for constants. Modules should be named whatever they export and return. If you have a module that returns a custom yielding function which uses RunService.Heartbeat , the module should be named Heartbeat .","title":"Naming"},{"location":"#prototype-classes","text":"First of, Luau has no concept of classes, hence a class in Lua is actually a prototype class or a object where other objects inherit from it, also known as Prototype Inheritance . First up, we create a empty table which will be the prototype class: local MyClass = {} Next, we assign the __index member on the class back to itself. This is a handy trick that lets us use the class's table as the metatable for instances as well. When we construct an instance, we'll tell Lua to use our __index value to find values that are missing in our instances: MyClass . __index = MyClass In most cases, we create a default constructor for our class. By convention, we usually call it new. Methods that don't operate on instances of our class are usually defined using a dot (.) (static methods) instead of a colon (:) (instance methods): function MyClass . new () return setmetatable ({ phrase = \"bark\" }, MyClass ) end -- This is functionally identical to `function MyClass.bark(self)` function MyClass : bark () print ( \"My phrase is\" , self . phrase ) end We can construct instances (objects) and start tinkering with it: local instance = MyClass . new () -- Properties on the instance are visible, since it's just a table: print ( instance . phrase ) -- \"bark\" -- Methods are pulled from MyClass because of our metatable: instance : bark () -- \"My phrase is bark\" -- We can also invoke methods with a dot by explicitly passing `instance`: MyClass . bark ( instance ) instance . bark ( instance ) Further additions you can make to your class as needed: Introduce a __tostring metamethod to make debugging easier. Add a method to check type given an instance, like: function MyClass . IsMyClass ( instance ) return getmetatable ( instance ). __index == MyClass end","title":"Prototype Classes"},{"location":"#general-whitespace","text":"It's always best to indent with tabs. Keep lines under 140 columns wide, assuming four column wide tabs. Wrap comments to 100 columns wide, assuming four column wide tabs. This is different than normal code; the hope is that short lines help improve readability of comment prose, but is too restrictive for code. Don't leave whitespace at the end of lines. Add a newline at the end of the file. No vertical alignment, they make code more difficult to edit and it's hard to keep exact precision and is a tedious process to do so anyways. Good : local bo = 132 local nanako = 17 Bad : local bo = 132 local nanako = 17 Use one statement per line. Put function bodies on new lines: Good : table.sort ({}, function ( a , b ) local sum = a + b return math.abs ( sum ) > 2 end ) Bad : table.sort ({}, function ( a , b ) local sum = a + b return math.abs ( sum ) > 2 end This is also true for if blocks, even if their body is just a return statement. Consistency is important! Good : if valueIsInvalid then return end Bad : if valueIsInvalid then return end Put function arguments (if they're too long) in new lines and expand the whitespace for the call: Good : local function foo (...) return ... end foo ( 1 , 2 , {}, {}, function () end , function () print ( \"test\" ) end ) Bad : local function foo (...) return ... end foo ( 1 , 2 , {}, {}, function () end , function () print ( \"test\" ) end ) Put a space before and after operators, except when clarifying precedence: Good : print ( 2 + 2 - 4 / 4 ) Bad : print ( 2 + 2 - 4 / 4 ) Avoid putting curly braces for tables on their own line. Doing so harms readability, since it forces the reader to move to another line in an awkward spot in the statement. Good : local foo = { bar = { baz = \"baz\" , }, } frob ({ x = 1 , }) Bad : local foo = { bar = { baz = \"baz\" , }, } frob ( { x = 1 , }) Exception: In function calls with large inline tables or functions, sometimes it's more clear to put braces and functions on new lines: foo ( { type = \"foo\" , bo = \"e\" , \"2\" {}, {} }, function ( something ) print ( \"Hello,\" something ) end ) Break dictionary-like tables with more than a couple keys onto multiple lines: Good : local profile = { Data = { Cash = 0 , Level = 1 }, MetaData = {} } Bad : local profile = { Data = { Cash = 0 , Level = 1 }, MetaData = {}}","title":"General Whitespace"},{"location":"#guarding-against-silent-errors","text":"Indexing into a table in Luau gives you nil if the key isn't present, which can cause errors that are difficult to trace! Our other major use case for metatables is to prevent certain forms of this problem. For types that act like enums, we can carefully apply an __index metamethod that throws: local MyEnum = { A = \"A\" , B = \"B\" , C = \"C\" , } setmetatable ( MyEnum , { __index = function ( self , key ) error ( string.format ( \"%q is not a valid member of MyEnum\" , tostring ( key )), 2 ) end , }) Since the __index metamethod is only called when a key is missing in the table, MyEnum.A and MyEnum.B will still give you back the expected values. But MyEnum.Typo will result in an error. Some nice debugging practices.","title":"Guarding against silent errors"},{"location":"#blocks","text":"Don't use parentheses around the conditions in if, while, or repeat blocks. They aren't necessary in Luau and usually harm readability. Good : if CONDITION then end while CONDITION do end Bad : if ( CONDITION ) then end while ( CONDITION ) do end Use do blocks if limiting the scope of a variable is useful: local getId do local lastId = 0 getId = function () lastId = lastId + 1 return lastId end end","title":"Blocks"},{"location":"#string-literals","text":"Use double quotes when declaring string literals. Good : local message = \"Hi\" Bad : local message = 'Hi' Use single quotes when declaring string literals that represent characters. Good : local characterA = 'A' Bad : local characterA = \"A\"","title":"String literals"},{"location":"#events-and-yielding","text":"Never unnecessary poll if you can use an event instead. Busy polling is bad practice as it constantly yields the thread back and forth, while yielding until an event is fired simply yields the thread once, and resumes it once. Remember the rule: Event Driven Programming > Unnecessary polling . Good : local Players = game : GetService ( \"Players\" ) local MIN_PLAYER_COUNT = 3 -- Wait for enough players to start: local playerCount = # Players : GetPlayers () while playerCount < MIN_PLAYER_COUNT do Players . PlayerAdded : Wait () playerCount += 1 -- Don't use GetPlayers() unnecessary end Bad : local Players = game : GetService ( \"Players\" ) local MIN_PLAYER_COUNT = 3 -- Wait for enough players to start: local playerCount = # Players : GetPlayers () while playerCount < MIN_PLAYER_COUNT do playerCount = # Players : GetPlayers () wait () end","title":"Events and yielding"},{"location":"#garbage-collection","text":"Always make sure strong references do get cleared in your code. Never have a reference that is never cleared. An reference type object (table, userdata, string, function, thread) are garbage collected when they have 0 references. Functions that use an external local variable hold reference to them (assuming they're reference type objects). The function will only no longer hold a reference to them once the function it self is garbage collected. Always disconnect events when they're no longer in need. Events hold an internal reference to the connected callback, and that callback will not be garbage collected unless the event it self is disconnected (event's disconnected no longer reference the connected callback). You can use a Maid to easily track events and clean them up.","title":"Garbage collection"},{"location":"#comments","text":"You don't need to necessarily use comments if the code is self explanatory. Although comments should both explain why and what the code is doing in simple terms.","title":"Comments"}]}